# VICE and Voyant Tools

## 2023-05-07
### Basic Voyant Tools setup
- If you work on a corpus and change the settings, remember to [bookmark (export) your current state](https://voyant-tools.org/docs/#!/guide/start-section-bookmarking-your-corpus) in order to access it later again
- Running Voyant Tools locally isn't strictly necessary, but it improved speed in my case
	- Setup Voyant Server [according to the guide](https://voyant-tools.org/docs/#!/guide/server)
	- Run into problems on launching VoyantServer on macOS; had to give the Java Runtime Environment **[Full Disk Access](https://discussions.apple.com/thread/254608797)** and start the server via [shell](https://brogramo.com/java-application-launch-failed-check-console-for-possible-error-message/)
- Copied all `.c` and all `.h` files from the `src` folder into a new Voyant project (ignore the import warning). This also means I flattened the hierarchy in which the files were organized. I believe this to be neglectable in the case of VICE
- Deactivate [stopwords](https://voyant-tools.org/docs/#!/guide/stopwords), since in code every word can have meaning and is not just syntactic glue
- Add [categories](https://voyant-tools.org/docs/#!/guide/categories) and colour-coded them

### Stopwords and categories for C
Here is a list of relevant stopwords generated by ChatGPT or Github Codepilot, provided by Moritz Mähr.

- Data Types
	- char , double , float , int , long , short , signed , unsigned , void , _Bool
 - Control Flow Keywords
	- break, continue, do, else, for, goto, if, return, switch, while
- Storage Class Keywords
	- auto, extern, register, static, typedef
- Type Qualifiers
	- const, restrict, volatile
- Other Keywords
	- _Alignas, _Alignof, _Atomic, _Complex, _Generic, _Imaginary, _Noreturn, _Static_assert, _Thread_local

### To look into
- Categories (Keywords, Comments etc.)
- Contexts word sequences: [collocates graph](https://voyant-tools.org/docs/#!/guide/collocatesgraph) , [corpus collocates](https://voyant-tools.org/docs/#!/guide/corpuscollocates) , [contexts](https://voyant-tools.org/docs/#!/guide/contexts) , [phrases](https://voyant-tools.org/docs/#!/guide/phrases) , [wordtree](https://voyant-tools.org/docs/#!/guide/wordtree)
- [Topics](https://voyant-tools.org/docs/#!/guide/topics) and [trends](https://voyant-tools.org/docs/#!/guide/trends)

### First thoughts
- This is very messy…

## 2023-05-17
After a rather messy start with the complete corpus, I wanted to have a go at just the comments. I tried my luck with regex and search and replace, first in vscodium, then in a bash-onliner (with find and sed) to remove everything that is not a comment. Spent a few hours on this problem without much luck, mainly because vscodium couldn't handle search and replace and several thousand files. I reverted to working with python and asked ChatGPT to produce me a script that solved my problem…

My prompt "`I need a python script that goes through a folder with files, searches through them with a regex pattern and copies the matches into new files`" resulted in a proposition which I needed to tweak a bit to work as intended. That took me 20 minutes in the end.

```python
import os
import re

def search_and_copy_files(folder_path, regex_pattern):
    # Create a regex pattern object
    pattern = re.compile(regex_pattern)

    # Iterate over files in the folder
    for filename in os.listdir(folder_path):
        file_path = os.path.join(folder_path, filename)

        # Check if it's a file
        if os.path.isfile(file_path):
            # Open the file for reading
            print(file_path)
            with open(file_path, 'r') as file:
                content = file.read()

            # Search for matches using the regex pattern
            matches = re.findall(pattern, content)

            # If there are matches, create a new file and copy the matching content
            if matches:
                new_filename = f"matches_{filename}"
                new_file_path = os.path.join('comments/', new_filename)

                # Open the new file for writing
                with open(new_file_path, 'w') as new_file:
                    # Write the matching content to the new file
                    new_file.write('\n'.join(matches))

                print(f"Matches found in {filename}. Copied to {new_filename}")

# Specify the folder path and regex pattern
folder_path = 'files/'
regex_pattern = re.compile(r'/\*(.*?)\*/', re.DOTALL)

# Call the function to search and copy files
search_and_copy_files(folder_path, regex_pattern)
```

I already had the regex pattern in place. After the clean-up, I loaded everything into a new corpus and started to play a bit. It shows that I don't have much experience with text mining, but at least it already seemed more meaningful. This new corpus, based just on the comment, will be the starting point for a later exploration.